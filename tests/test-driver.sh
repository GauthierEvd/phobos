#!/bin/bash
# -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil; -*-
# vim:expandtab:shiftwidth=4:tabstop=4:

# test-driver - basic testsuite driver script.
scriptversion=2022-11-16; # UTC

# Copyright (C) 2011-2013 Free Software Foundation, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
# As a special exception to the GNU General Public License, if you
# distribute this file as part of a program that contains a
# configuration script generated by Autoconf, you may include it under
# the same distribution terms that you use for the rest of that program.

#  All rights reserved (c) 2014-2022 CEA/DAM.
#
#  This file is part of Phobos.
#
#  Phobos is free software: you can redistribute it and/or modify it under
#  the terms of the GNU Lesser General Public License as published by
#  the Free Software Foundation, either version 2.1 of the License, or
#  (at your option) any later version.
#
#  Phobos is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU Lesser General Public License for more details.
#
#  You should have received a copy of the GNU Lesser General Public License
#  along with Phobos. If not, see <http://www.gnu.org/licenses/>.
#

# Tests can define one function for global setup in $TEST_SETUP and one function
# for global cleanup in $TEST_CLEANUP. Moreover, actual test functions (called
# sub-tests) are defined in $TESTS, and can be of two different forms:
# 1. A simple string, of the form "sub-test_1", which will be executed in a
#    subshell
# 2. A string containing spaces, of the form "sub-setup sub-test_1 ...
# sub-test_N sub-cleanup". In this form, the sub-setup will be executed, then
# all the sub-tests, and finally the sub-cleanup

usage_error ()
{
  echo "$0: $*" >&2
  print_usage >&2
  exit 2
}

print_usage ()
{
  cat <<END
Usage:
  test-driver --test-name=NAME --log-file=PATH --trs-file=PATH
              [--expect-failure={yes|no}] [--color-tests={yes|no}]
              [--enable-hard-errors={yes|no}] [--] TEST-SCRIPT
The '--test-name', '--log-file' and '--trs-file' options are mandatory.
END
}

test_name= # Used for reporting.
log_file=  # Where to save the output of the test script.
trs_file=  # Where to save the metadata of the test run.
expect_failure=no
color_tests=no
enable_hard_errors=yes
while test $# -gt 0; do
  case $1 in
  --help) print_usage; exit $?;;
  --version) echo "test-driver $scriptversion"; exit $?;;
  --test-name) test_name=$2; shift;;
  --log-file) log_file=$2; shift;;
  --trs-file) trs_file=$2; shift;;
  --color-tests) color_tests=$2; shift;;
  --expect-failure) expect_failure=$2; shift;;
  --enable-hard-errors) enable_hard_errors=$2; shift;;
  --) shift; break;;
  -*) usage_error "invalid option: '$1'";;
  esac
  shift
done

if test $color_tests = yes; then
  # Keep this in sync with 'lib/am/check.am:$(am__tty_colors)'.
  red='[0;31m' # Red.
  grn='[0;32m' # Green.
  lgn='[1;32m' # Light green.
  blu='[1;34m' # Blue.
  mgn='[0;35m' # Magenta.
  pur='[38:5:5m' # Purple.
  cya='[0;36m' # Cyan.
  ylw='[0;33m' # Yellow.
  std='[m'     # No color.
else
  red= grn= lgn= blu= mgn= std=
fi

do_exit='rm -f $log_file $trs_file; (exit $st); exit $st'
trap "st=129; $do_exit" 1
trap "st=130; $do_exit" 2
trap "st=141; $do_exit" 13
trap "st=143; $do_exit" 15

# Status printer, to show if a sub-test or setup/cleanup was either completed,
# skipped or failed. Also show the time taken by the sub-test if provided
function print_status
{
    local rc=$1
    local taken=$2

    if [[ "$rc" -eq 0 ]]; then
        echo "${grn}✔${std} $taken"
    elif [[ "$rc" -eq 77 ]]; then
        echo "${red}⏭${std}"
    else
        echo "${red}✖${std} $taken"
    fi
}

# Execute the setup, and show it to stdout and in the log_file
function do_setup
{
    local test_setup=$(echo "$1" | xargs)
    declare rc

    echo -e "SETUP: $test_setup\n" >> $log_file
    echo -n "    $test_setup: "
    set -x
    $test_setup >> $log_file 2>&1
    rc=$?
    set +x

    print_status $rc
    return $rc
}

# Execute the sub-test in a subshell, and show the start, result, and time taken
# to stdout, and the start and output in the log_file.
function do_test
{
    local test_func=$(echo "$1" | xargs)
    declare rc

    echo -e "FUNCTION: $test_func\n" >> $log_file
    echo -n "        $test_func: "
    before=$(date +%s.%N)
    (set -xe; $test_func >>$log_file 2>&1)
    rc=$?
    after=$(date +%s.%N)
    taken=$(echo "($(echo "$after - $before" | bc))")

    print_status $rc $taken
    return $rc
}

# Execute the cleanup, and show it to stdout and in the log_file
function do_cleanup
{
    local test_cleanup=$(echo "$1" | xargs)
    declare rc

    echo -e "CLEANUP: $test_cleanup\n" >> $log_file
    echo -n "    $test_cleanup: "
    set -x
    $test_cleanup >> $log_file 2>&1
    rc=$?
    set +x

    print_status $rc
    return $rc
}

# Functions provided for the test files

# Error will simply return 1 and not exit to easily manage the errors as it can
# be called in setups/cleanups
function error ()
{
    echo "$*" >> $log_file 2>&1
    return 1
}

# Skip will exit with the skip error code (77). This can only be called in
# sub-tests, not in setups or cleanups as it would skip the whole test.
function skip ()
{
    echo "$*" >> $log_file 2>&1
    # Exit instead of return because a return would be caught as an error by
    # a set -e, which would turn into an "exit 1" and not a skip.
    exit 77
}

# Noop can be used to provide an empty setup/cleanup to tests if required
function noop ()
{
    echo "noop function" > /dev/null
}

# Report test start (best line of the file bar none)
echo "${red}S${ylw}T${grn}A${cya}R${blu}T${pur}:${std} $test_name"

truncate -s 0 $log_file

# Everything is done in a subshell
(

# Consider the test may be skipped
estatus=77

# Source the file to retrieve the TESTS, TEST_SETUP and TEST_CLEANUP variables
source "$@" >> $log_file 2>&1

# Redirect the "set -x" output to the log file
exec 19>> $log_file
BASH_XTRACEFD=19

# Trap the global cleanup call if there is one
if [ ! -z $TEST_CLEANUP ]; then
    trap "do_cleanup $TEST_CLEANUP" EXIT
fi

# Execute the global setup if there is one
if [ ! -z $TEST_SETUP ]; then
    do_setup $TEST_SETUP
    # If the setup failed, immediately exit
    rc=$?
    if (( rc != 0 )); then
        exit $rc
    fi
fi

# Parse the TESTS array
for t in "${TESTS[@]}"; do
    # Parse each string of the array
    for i in $(seq 0 $((${#t[@]} - 1))); do
        # Split string on semicolon to list subtests and setup/cleanup
        IFS=';' read -r -a array <<< "${t[i]}"
        # If the string has a single element (i.e. no semicolon), then we just
        # execute the sub-test
        if (( ${#array[@]} == 1 )); then
            do_test "${array[0]}"
            # If the sub-test succeeds, mark the test as successful. If it
            # fails, mark it as a failure and abort the test
            rc=$?
            if (( $rc == 0 )); then
                estatus=0
            elif (( $rc != 77 )); then
                exit $rc
            fi
        else
            # If the string contains multiple semicolons, we start another
            # subshell to keep the setup/cleanup localized and easier to use
            (
            # We consider the last element of the string array as the cleanup,
            # so we trap it, and the first element to be the setup
            trap "do_cleanup '${array[-1]}'" EXIT
            do_setup "${array[0]}"
            # Likewise, if the setup fails, just exit the subshell and
            # propagate the error
            rc=$?
            if (( $rc != 0 )); then
                exit $rc
            fi
            # For each element in the array that isn't the setup or cleanup, we
            # execute the function and mark either the test as successful or
            # failure
            for test_func in "${array[@]:1:${#array[@]}-2}"; do
                do_test "$test_func"
                rc=$?
                if (( $rc == 0 )); then
                    estatus=0
                elif (( $rc != 77 )); then
                    estatus=$rc
                    break
                fi
            done

            # Remove the trap and execute the cleanup
            trap "" EXIT
            do_cleanup "${array[-1]}"
            # Propagate the error if the cleanup is the only part of the test
            # that failed
            rc=$?
            if (( $rc != 0 && ( "$estatus" == 0 || "$estatus" == 77 ) )); then
                estatus=$rc
            fi

            exit $estatus
            )
            estatus=$?
            if (( $estatus != 0 && $estatus != 77 )); then
                exit $estatus
            fi
        fi
    done
done

exit $estatus
)
estatus=$?

if test $enable_hard_errors = no && test $estatus -eq 99; then
  estatus=1
fi

case $estatus:$expect_failure in
  0:yes) col=$red res=XPASS recheck=yes gcopy=yes;;
  0:*)   col=$grn res=PASS  recheck=no  gcopy=no;;
  77:*)  col=$blu res=SKIP  recheck=no  gcopy=yes;;
  99:*)  col=$mgn res=ERROR recheck=yes gcopy=yes;;
  *:yes) col=$lgn res=XFAIL recheck=no  gcopy=yes;;
  *:*)   col=$red res=FAIL  recheck=yes gcopy=yes;;
esac

# Report outcome to console.
echo "${col}${res}${std}: $test_name"

# Register the test result, and other relevant metadata.
echo ":test-result: $res" > $trs_file
echo ":global-test-result: $res" >> $trs_file
echo ":recheck: $recheck" >> $trs_file
echo ":copy-in-global-log: $gcopy" >> $trs_file

# Local Variables:
# mode: shell-script
# sh-indentation: 2
# eval: (add-hook 'write-file-hooks 'time-stamp)
# time-stamp-start: "scriptversion="
# time-stamp-format: "%:y-%02m-%02d.%02H"
# time-stamp-time-zone: "UTC"
# time-stamp-end: "; # UTC"
# End:
